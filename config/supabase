// Configuration Supabase
const supabaseConfig = {
    // 🔧 Configuration principale
    url: 'https://votre-projet.supabase.co',
    anonKey: 'votre-cle-api-publique',
    
    // ⚙️ Options avancées
    options: {
        auth: {
            autoRefreshToken: true,
            persistSession: true,
            detectSessionInUrl: true
        },
        realtime: {
            params: {
                eventsPerSecond: 10
            }
        }
    },

    // 📋 Structure des tables recommandées
    schema: {
        employees: {
            id: 'uuid primary key default gen_random_uuid()',
            name: 'text not null',
            email: 'text unique not null',
            department: 'text',
            position: 'text',
            join_date: 'timestamp with time zone default now()',
            active: 'boolean default true',
            created_at: 'timestamp with time zone default now()',
            updated_at: 'timestamp with time zone default now()'
        },
        
        feedbacks: {
            id: 'uuid primary key default gen_random_uuid()',
            employee_id: 'uuid references employees(id)',
            category: 'text not null',
            message: 'text not null',
            priority: 'text default \'medium\'',
            status: 'text default \'unread\'',
            anonymous: 'boolean default false',
            created_at: 'timestamp with time zone default now()',
            updated_at: 'timestamp with time zone default now()'
        },
        
        moods: {
            id: 'uuid primary key default gen_random_uuid()',
            employee_id: 'uuid references employees(id)',
            mood_score: 'integer check (mood_score >= 1 and mood_score <= 5)',
            date: 'date not null',
            comment: 'text',
            created_at: 'timestamp with time zone default now()'
        },
        
        surveys: {
            id: 'uuid primary key default gen_random_uuid()',
            title: 'text not null',
            description: 'text',
            questions: 'jsonb',
            status: 'text default \'active\'',
            start_date: 'timestamp with time zone default now()',
            end_date: 'timestamp with time zone',
            created_by: 'uuid references employees(id)',
            created_at: 'timestamp with time zone default now()',
            updated_at: 'timestamp with time zone default now()'
        },
        
        survey_responses: {
            id: 'uuid primary key default gen_random_uuid()',
            survey_id: 'uuid references surveys(id)',
            employee_id: 'uuid references employees(id)',
            answers: 'jsonb not null',
            submitted_at: 'timestamp with time zone default now()'
        },
        
        trainings: {
            id: 'uuid primary key default gen_random_uuid()',
            title: 'text not null',
            description: 'text',
            instructor: 'text',
            start_date: 'timestamp with time zone',
            end_date: 'timestamp with time zone',
            status: 'text default \'scheduled\'',
            max_participants: 'integer',
            created_at: 'timestamp with time zone default now()',
            updated_at: 'timestamp with time zone default now()'
        },
        
        training_ratings: {
            id: 'uuid primary key default gen_random_uuid()',
            training_id: 'uuid references trainings(id)',
            employee_id: 'uuid references employees(id)',
            rating: 'integer check (rating >= 1 and rating <= 5)',
            comment: 'text',
            created_at: 'timestamp with time zone default now()'
        }
    },

    // 🔐 Politiques de sécurité RLS (Row Level Security)
    policies: {
        employees: [
            'CREATE POLICY "Employees can view own profile" ON employees FOR SELECT USING (auth.uid() = id)',
            'CREATE POLICY "HR can view all employees" ON employees FOR SELECT USING (auth.jwt() ->> \'role\' = \'hr_admin\')',
            'CREATE POLICY "HR can update employees" ON employees FOR UPDATE USING (auth.jwt() ->> \'role\' = \'hr_admin\')'
        ],
        
        feedbacks: [
            'CREATE POLICY "Employees can insert own feedback" ON feedbacks FOR INSERT WITH CHECK (auth.uid() = employee_id)',
            'CREATE POLICY "HR can view all feedbacks" ON feedbacks FOR SELECT USING (auth.jwt() ->> \'role\' = \'hr_admin\')',
            'CREATE POLICY "Employees can view own feedback" ON feedbacks FOR SELECT USING (auth.uid() = employee_id)'
        ],
        
        moods: [
            'CREATE POLICY "Employees can insert own mood" ON moods FOR INSERT WITH CHECK (auth.uid() = employee_id)',
            'CREATE POLICY "HR can view mood analytics" ON moods FOR SELECT USING (auth.jwt() ->> \'role\' = \'hr_admin\')',
            'CREATE POLICY "Employees can view own moods" ON moods FOR SELECT USING (auth.uid() = employee_id)'
        ]
    },

    // 📊 Vues pour l'analytics
    views: {
        mood_analytics: `
            CREATE VIEW mood_analytics AS
            SELECT 
                date,
                AVG(mood_score) as average_mood,
                COUNT(*) as response_count,
                COUNT(CASE WHEN mood_score >= 4 THEN 1 END) as positive_responses,
                COUNT(CASE WHEN mood_score <= 2 THEN 1 END) as negative_responses
            FROM moods 
            GROUP BY date 
            ORDER BY date DESC
        `,
        
        feedback_summary: `
            CREATE VIEW feedback_summary AS
            SELECT 
                category,
                priority,
                COUNT(*) as total_count,
                COUNT(CASE WHEN status = 'unread' THEN 1 END) as unread_count,
                DATE_TRUNC('week', created_at) as week
            FROM feedbacks 
            GROUP BY category, priority, week
            ORDER BY week DESC, total_count DESC
        `,
        
        survey_participation: `
            CREATE VIEW survey_participation AS
            SELECT 
                s.id,
                s.title,
                s.status,
                COUNT(sr.id) as response_count,
                (SELECT COUNT(*) FROM employees WHERE active = true) as total_employees,
                ROUND(
                    (COUNT(sr.id)::float / (SELECT COUNT(*) FROM employees WHERE active = true)) * 100, 
                    2
                ) as participation_rate
            FROM surveys s
            LEFT JOIN survey_responses sr ON s.id = sr.survey_id
            GROUP BY s.id, s.title, s.status
        `
    },

    // ⚡ Fonctions Supabase (Edge Functions)
    functions: {
        'calculate-mood-trend': {
            description: 'Calcule la tendance des humeurs sur une période',
            parameters: {
                days: 'number (défaut: 7)',
                department: 'string (optionnel)'
            }
        },
        
        'generate-report': {
            description: 'Génère un rapport personnalisé',
            parameters: {
                type: 'string (mood|feedback|survey)',
                period: 'string (7d|30d|90d)',
                format: 'string (json|pdf)'
            }
        },
        
        'send-notification': {
            description: 'Envoie une notification aux employés',
            parameters: {
                message: 'string',
                type: 'string (info|warning|success)',
                target: 'string (all|department|individual)'
            }
        }
    },

    // 🔔 Configuration temps réel
    realtime: {
        channels: {
            'hr-dashboard': {
                events: ['feedback_created', 'mood_updated', 'survey_response'],
                tables: ['feedbacks', 'moods', 'survey_responses']
            }
        }
    },

    // 📱 Configuration PWA
    pwa: {
        name: 'HR Dashboard',
        short_name: 'HR',
        description: 'Tableau de bord RH pour la gestion d\'équipe',
        theme_color: '#667eea',
        background_color: '#ffffff',
        display: 'standalone',
        scope: '/',
        start_url: '/'
    }
};

// 🚀 Initialisation Supabase
async function initializeSupabase() {
    try {
        // Vérification de la disponibilité de Supabase
        if (typeof supabase === 'undefined') {
            console.warn('⚠️ Supabase client non disponible - Mode simulation activé');
            return false;
        }

        // Initialisation du client
        const client = supabase.createClient(
            supabaseConfig.url,
            supabaseConfig.anonKey,
            supabaseConfig.options
        );

        // Test de connexion
        const { data, error } = await client.from('employees').select('count').limit(1);
        
        if (error) {
            console.error('❌ Erreur de connexion Supabase:', error);
            return false;
        }

        console.log('✅ Supabase initialisé avec succès');
        
        // Configuration du temps réel
        setupRealtimeSubscriptions(client);
        
        return client;

    } catch (error) {
        console.error('❌ Échec d\'initialisation Supabase:', error);
        return false;
    }
}

// 🔄 Configuration des abonnements temps réel
function setupRealtimeSubscriptions(client) {
    const channel = client
        .channel('hr-dashboard')
        .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'feedbacks'
        }, (payload) => {
            console.log('📝 Nouveau feedback:', payload);
            document.dispatchEvent(new CustomEvent('realTimeUpdate', {
                detail: { type: 'feedback', data: payload.new }
            }));
        })
        .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'moods'
        }, (payload) => {
            console.log('😊 Nouvelle humeur:', payload);
            document.dispatchEvent(new CustomEvent('realTimeUpdate', {
                detail: { type: 'mood', data: payload.new }
            }));
        })
        .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'survey_responses'
        }, (payload) => {
            console.log('📊 Nouvelle réponse sondage:', payload);
            document.dispatchEvent(new CustomEvent('realTimeUpdate', {
                detail: { type: 'survey', data: payload.new }
            }));
        })
        .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
                console.log('🔔 Abonnements temps réel actifs');
            }
        });

    return channel;
}

// 📋 Scripts SQL pour la création des tables
const createTablesSQL = `
-- Activer RLS
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE feedbacks ENABLE ROW LEVEL SECURITY;
ALTER TABLE moods ENABLE ROW LEVEL SECURITY;
ALTER TABLE surveys ENABLE ROW LEVEL SECURITY;
ALTER TABLE survey_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE trainings ENABLE ROW LEVEL SECURITY;
ALTER TABLE training_ratings ENABLE ROW LEVEL SECURITY;

-- Créer les tables (voir supabaseConfig.schema pour les définitions)

-- Créer les vues
${supabaseConfig.views.mood_analytics}
${supabaseConfig.views.feedback_summary}
${supabaseConfig.views.survey_participation}

-- Créer les politiques RLS
${supabaseConfig.policies.employees.join(';\n')}
${supabaseConfig.policies.feedbacks.join(';\n')}
${supabaseConfig.policies.moods.join(';\n')}

-- Créer des fonctions utilitaires
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Ajouter des triggers pour updated_at
CREATE TRIGGER update_employees_updated_at BEFORE UPDATE ON employees
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_feedbacks_updated_at BEFORE UPDATE ON feedbacks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_surveys_updated_at BEFORE UPDATE ON surveys
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_trainings_updated_at BEFORE UPDATE ON trainings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
`;

// 🔧 Utilitaires Supabase
const supabaseUtils = {
    // Formatage des erreurs Supabase
    formatError(error) {
        const errorMessages = {
            '23505': 'Cette entrée existe déjà',
            '23503': 'Référence invalide',
            '42501': 'Permissions insuffisantes',
            'PGRST116': 'Table non trouvée'
        };
        
        return errorMessages[error.code] || error.message || '